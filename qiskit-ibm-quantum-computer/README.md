# README

## Deutsch-Jozsa Algorithm

### Overview

The code here is organized as a function that creates the unitary matrix U_f 
given a function f that is either constant or balanced and the rest of the code 
functions as interactive script that lets you enter in all input output pairs 
in order to create the function f (represented as a python dictionary). The 
output is a final print statement to console that tells us whether the function 
is balanced or constant. 

### Input 

The input is first the number of bit the function operates on and then the 
input output pairs that specify the function and is parsed from console. The 
format is as shown in the example below. 

An example of this is: 
```
no. of qubits: 2
Enter input, output pairs each in a line:
00 0
01 1
10 1
11 0
```

### How to Execute

The program is written as a script so as soon as you enter the function in the 
manner described in the way above, the program begins executing automatically. 

### Output 

The output of the program is many fold - the program prints useful information 
about every step of the program. In particular, the program prints the unitary 
matrix U_f that corresponds to the function and then prints the results of each 
trial that the quantum algorithm was run for. 
However, the final output which is the answer to the question whether or not 
the function f is balanced is printed at the very end with 'Balanced' to 
indicate that the function is indeed balanced and 'Constant' to indicate that 
is constant. 

An example of the output: 

```
[[1. 0. 0. 0. 0. 0. 0. 0.]
 [0. 1. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 1. 0. 0. 0. 0.]
 [0. 0. 1. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 1. 0. 0.]
 [0. 0. 0. 0. 1. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 1. 0.]
 [0. 0. 0. 0. 0. 0. 0. 1.]]
State of qubits without helper qubit in each trail
0 : 11
1 : 11
2 : 11
3 : 11
4 : 11
5 : 11
6 : 11
7 : 11
8 : 11
9 : 11
Balanced
```

Note that the final output answering the question this algorithm was meant to 
ask is given on the final line. 

### Example Usage

```
sjoshi@Siddharths-MacBook-Air pyquil % python3 deutsch_jozsa.py 
no. of qubits: 2
Enter input, output pairs each in a line:
00 0
01 1
10 1
11 0
[[1. 0. 0. 0. 0. 0. 0. 0.]
 [0. 1. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 1. 0. 0. 0. 0.]
 [0. 0. 1. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 1. 0. 0.]
 [0. 0. 0. 0. 1. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 1. 0.]
 [0. 0. 0. 0. 0. 0. 0. 1.]]
State of qubits without helper qubit in each trail
0 : 11
1 : 11
2 : 11
3 : 11
4 : 11
5 : 11
6 : 11
7 : 11
8 : 11
9 : 11
Balanced
```

## Bernstein-Vazirani Algorithm

### Overview

For maximum clarity, the majority of the code is organized into a class called 
Solver. The class can be instantiated using the parameters of the problem such 
as the function f and the number of bits it operates on n. The user can then 
simply use their instance's .solve() method to obtain the solution. The 
solution returned by the algorithm is simply the value of a since b can be 
found easily by one call to the function on a classical computer. 

### Input
In particular:
``` 
Solver(f, n)
```
where:

* f is a function that takes as input a bit vector of length n
represented as a string of 0s and 1s (can be generated by 
np.binary_repr(int_corresponding_to_bit_vector, num_bits)) and returns as 
output an integer i.e. 0 or 1. 
* n is the number of bits f takes as input


### How to execute

This class has many useful functions such as generate_bit_strings, get_tensor, 
modify_bit_string, produce_u_f_gate, build_circuit and solve. However, all 
functions except solve are private and cannot be accessed by the user in order 
to hide information about the function f Nonetheless, the only function a user 
needs to use is solve() which would give the solution to the particular 
instantiation of the Bernstein Vazirani problem. 

An example of how to use this method is shown here:
```
solver = Solver(f, n)
solution = solver.solve()
```

### Output

The output of the 'solve' function is a bit vector represented as a python 
string containing only 0s and 1s. This bit vector represents the value of a as 
discovered by the algorithm. 

An example output is shown here:
```
'111'
```

### Example Code
```
# Test Code 
n = 3
f = lambda x: addition_mod_2(inner_product_mod_2("111", x), 1)

solver = Solver(f, n)
a = solver.solve()
print('Value of a: {}'.format(a))
print('Value of b: {}'.format(f("0"*n)))
```

## Grover's Algorithm

### Overview

For maximum clarity, the majority of the code is organized into a class called 
Solver. The class can be instantiated using the parameters of the problem such 
as the function f and the number of bits it operates on n. The user can then 
simply use their instance's .solve() method to obtain the solution. 

### Input
In particular:
``` 
Solver(f, n)
```
where:

* f is a function that takes as input a bit vector of length n
represented as a string of 0s and 1s (can be generated by 
np.binary_repr(int_corresponding_to_bit_vector, num_bits)) and returns as 
output an integer i.e. 0 or 1. 
* n is the number of bits f takes as input

### How to execute

This class has many useful functions such as generate_bit_strings, 
produce_z_0_gate, produce_z_f_gate, produce_negative_gate, build_circuit and 
solve. However, all functions except solve are private and cannot be accessed 
by the user in order to hide information about the function f Nonetheless, the 
only function a user needs to use is solve() which would give the solution to 
the particular instantiation of the Grover Search problem. 

An example of how to use this method is shown here:
```
solver = Solver(f, n)
solution = solver.solve()
```

### Output

The output of the 'solve' function is a list of bit vectors represented as list 
of python string containing only 0s and 1s. Each bit vector in this list 
represents the output of a trial and since Grover doesn't guarantee that we 
find a solution, we thought it'd be useful to get the 'solution' found in each 
trial and let the user observe this. A simple for loop through this, applying f 
to each value can check whether or not the given value is the value for which f 
= 1. 

An example output is shown here:
```
['101', '101', '101', '101', '101', '101', '101', '101', '101', '101']
```

### Example Code
```
# Test Code 
n=3
f = lambda x: 1 if x=="101" else 0

solver = Solver(f, n)
xs = solver.solve()

for idx, x in enumerate(xs):
    print("Trial {}, x: {}".format(idx, x))
```


## Simon's Algorithm

### Overview

For maximum clarity, the majority of the code is organized into a class called 
Simon.
This class has a constructor that requires a connection to a quantum computer, 
the function f we wish to decode the secret for, the number of bits f takes as 
input and
the number of iterations we wish to run for. The class has a method run which 
runs the computation and returns the outupt as a list of bit vectors 
(represenred as strings of 0s
and 1s). 

### Input
In particular:
``` 
Simon(qc, f, num_bits, max_iters)
```
where:

* qc is the connection object returned by get_qc(params).
* f is a function that takes as input a bit vector of length num_bits 
represented as a string of 0s and 1s (can be generated by 
np.binary_repr(int_corresponding_to_bit_vector, num_bits)) and returns as 
output a bit vector in the same format
* num_bits is an integer that is as specified in the previous point
* max_iters is an integer that controls how many iterations will the algorithm 
will run for which can be used to tweak the probability of success in finding 
s. 

### How to execute

This class has many useful functions such as create_unitary_matrix, 
create_circuit, solve_lin_system, bitwise_xor, run. However, the only 
function a user needs to use typically is run and after instatiating the class 
with the necessary parameters, the user can simply call the .run() method of 
the instance variable to run the program and return a list of candidates. The 
run variable takes no parameters. The user needs to just pass the backend of 
the quantum computer as the first positional argument (simulator) to use 
the exact same code as the previous assignment to run on an actual 
quantum computer. 

An example of how to use this method is shown here:
```
solver = Simon(qc, f, 2, 4)
candidates = solver.run()
```

### Output

The output of the 'run' function is a list of strings with each string 
representing a bit vector of length num_bits. This list is ideally length 2 
when the program is able to obtain n -1 linearly independent equations. 
However, if the program wasn't 
able to do so, the list contains all possible candidates. Thus the trivial 
candidate the string of all 0s is always included and depending on 
whether the function uses an s != 0 and how many linearly independent equations 
the quantum 
section of the algorithm is able to produce, there may be other members in this 
list. 

An example output is shown here:
```
['00', '11']
```

This output can be understood as indicating that there are two solutions to the 
system of linear equations found and in fact in this case i.e. when there are 
just two elements in the list of candidates we know for a fact that we have 
successfully found the secret s and know exactly what it is.

### Example Code
```
# Test Code - Uncomment block to use
n = 4
test_secret = np.binary_repr(0, n)
def func_no_secret(x):
    func_dict = create_1to1_dict(mask=np.binary_repr(1, n))
    return func_dict[x]

def func_secret(x):
    func_dict = create_2to2_dict(mask=np.binary_repr(1, n), secret=test_secret)
    return func_dict[x]

# Using an actual quantum computer
API_CREDENTIAL = "Your API Key"
IBMQ.save_account(API_CREDENTIAL, overwrite=True)
IBMQ.load_account()
provider = IBMQ.get_provider(hub='ibm-q')
qc = provider.get_backend("ibmq_16_melbourne")
solver = Simon(qc, func_secret, n, 8)
candidates = solver.run()
print(candidates) 
```