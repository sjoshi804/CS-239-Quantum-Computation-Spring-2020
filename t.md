# README

## Simon's Algorithm

### Overview

For maximum clarity, the majority of the code is organized into a class called 
Simon.
This class has a constructor that requires a connection to a quantum computer, 
the function f we wish to decode the secret for, the number of bits f takes as 
input and
the number of iterations we wish to run for. The class has a method run which 
runs the computation and returns the outupt as a list of bit vectors 
(represenred as strings of 0s
and 1s). 

### Input
In particular:
``` 
Simon(qc, f, num_bits, max_iters)
```
where:

* qc is the connection object returned by get_qc(params).
* f is a function that takes as input a bit vector of length num_bits 
represented as a string of 0s and 1s (can be generated by 
np.binary_repr(int_corresponding_to_bit_vector, num_bits)) and returns as 
output a bit vector in the same format
* num_bits is an integer that is as specified in the previous point
* max_iters is an integer that controls how many iterations will the algorithm 
will run for which can be used to tweak the probability of success in finding 
s. 

### How to execute

This class has many useful functions such as create_unitary_matrix, 
create_circuit, compile, solve_lin_system, bitwise_xor, run. However, the only 
function a user needs to use typically is run and after instatiating the class 
with the necessary parameters, the user can simply call the .run() method of 
the instance variable to run the program and return a list of candidates. The 
run variable takes no parameters. 

An example of how to use this method is shown here:
```
solver = Simon(qc, f, 2, 4)
candidates = solver.run()
```

### Output

The output is a list of strings with each string representing a bit vector of 
length num_bits. This list is ideally length 2 when the program is able to 
obtain n - 1 linearly independent equations. However, if the program wasn't 
able to do so, the list contains all possible candidates. Thus the trivial 
candidate the string of all 0s is always included and depending on 
whether the function uses an s != 0 and how many linearly independent equations 
the quantum 
section of the algorithm is able to produce, there may be other members in this 
list. 

An example output is shown here:
```
['00', '11']
```

This output can be understood as indicating that there are two solutions to the 
system of linear equations found and in fact in this case i.e. when there are 
just two elements in the list of candidates we know for a fact that we have 
successfully found the secret s and know exactly what it is.

### Example Code
```
# Test Code 
n = 2
test_secret = np.binary_repr(3, n)
def func_no_secret(x):
    func_dict = create_1to1_dict(mask=np.binary_repr(1, n))
    return func_dict[x]

def func_secret(x):
    func_dict = create_2to2_dict(mask=np.binary_repr(1, n), secret=test_secret)
    return func_dict[x]

qc = get_qc('9q-square-qvm')
qc.compiler.client.timeout = 10000
solver = Simon(qc, func_secret, n, 10)
candidates = solver.run()
if '00' in candidates:
    print("Test confirms '00' in candidates")
if test_secret in candidates:
    print("Test confirms " + str(test_secret) + " in candidates")
if len(candidates) == 2:
    print("Test confirms length is exactly 2") 
```